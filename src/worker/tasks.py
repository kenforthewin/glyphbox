"""Procrastinate task definitions for agent runs.

Each task runs in a worker process, completely separate from the web server.
The worker creates its own agent, API, and repository instances.

Tasks are registered on the module-level App from ``src.worker.app``.
The App must be configured (via ``configure(conninfo)``) before tasks are
imported by the worker or used for deferring.
"""

import logging

from src.worker.app import get_app

logger = logging.getLogger(__name__)

# Get the configured app for task registration.
# This import path is listed in App(import_paths=["src.worker.tasks"]),
# so procrastinate imports this module when the worker starts.
_app = get_app()


async def _mark_run_error(repo, run_id: str, reason: str) -> None:
    """Mark a run as errored in the database."""
    from datetime import datetime

    run = await repo.get_run(run_id)
    if run and run.status not in ("stopped", "error", "completed"):
        run.status = "error"
        run.end_reason = reason
        run.ended_at = datetime.now()
        await repo.update_run(run)


@_app.task(name="run_agent", queue="agent_runs")
async def run_agent_task(
    run_id: str,
    user_id: int,
    model: str,
    character: str = "random",
    temperature: float = 0.1,
    reasoning: str = "none",
    max_turns: int = 10000,
) -> None:
    """Execute a full agent run in a worker process.

    The task:
    1. Connects to the database
    2. Fetches the user record and decrypts their API key
    3. Creates the agent + game environment
    4. Runs the agent loop (persisting turns to the DB)
    5. Finalizes the run record on completion

    Cancellation is handled automatically: Procrastinate raises
    asyncio.CancelledError when a job is aborted, and
    WebAgentRunner._run_loop already handles that correctly.
    """
    from sqlalchemy.ext.asyncio import create_async_engine

    from src.config import load_config
    from src.persistence.postgres import PostgresRepository
    from src.web.agent_factory import create_agent_for_run
    from src.web.auth import decrypt_key
    from src.web.runner import WebAgentRunner

    logger.info(f"Worker picked up job: run_id={run_id}, model={model}")

    config = load_config()
    engine = create_async_engine(
        config.database.url,
        pool_size=config.database.pool_min_size,
    )

    try:
        repo = PostgresRepository(engine)

        # Fetch user and decrypt API key
        user = await repo.get_user(user_id)
        if not user:
            logger.error(f"User {user_id} not found, cannot run job {run_id}")
            await _mark_run_error(repo, run_id, f"User {user_id} not found")
            return

        if not user.encrypted_openrouter_key:
            logger.error(f"User {user_id} has no API key, cannot run job {run_id}")
            await _mark_run_error(repo, run_id, "No API key stored")
            return

        try:
            api_key = decrypt_key(user.encrypted_openrouter_key, config.auth.encryption_key)
        except Exception as e:
            logger.error(f"Failed to decrypt API key for run {run_id}: {e}")
            await _mark_run_error(repo, run_id, "Failed to decrypt API key")
            return

        # Create agent and game environment
        try:
            agent, api = create_agent_for_run(
                api_key=api_key,
                model=model,
                character=character,
                temperature=temperature,
                reasoning=reasoning,
                max_turns=max_turns,
            )
        except Exception as e:
            logger.error(f"Failed to create agent for run {run_id}: {e}")
            await _mark_run_error(repo, run_id, f"Agent setup failed: {e}")
            return

        # Create runner and start (run_id is pre-generated by web server)
        runner = WebAgentRunner(
            agent=agent,
            api=api,
            repo=repo,
            user_id=user_id,
        )
        await runner.start(run_id=run_id)
        logger.info(f"Worker started agent loop for run_id={run_id}")

        # Block until the run finishes (game over, error, or cancellation)
        await runner.wait()
        logger.info(f"Worker completed run_id={run_id}")

    except Exception:
        logger.exception(f"Unexpected error in worker task for run {run_id}")
        try:
            await _mark_run_error(repo, run_id, "Unexpected worker error")
        except Exception:
            logger.exception("Failed to mark run as errored")
        raise
    finally:
        await engine.dispose()
